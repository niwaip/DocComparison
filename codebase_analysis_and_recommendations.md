# 代码库结构分析与改进建议

### 总体评价

项目采用了一个非常好的基础架构模式：一个 **API服务器 (`server.ts`) + 后台工作进程 (`worker.ts`)**，通过消息队列（BullMQ）来解耦。这种模式对于处理耗时的文档分析和AI任务来说是最佳实践，可以有效避免API请求超时，并提高系统的吞吐量。

然而，当前的代码实现**在职责划分上存在明显的问题**，这使得项目难以维护和扩展。

---

### 1. 职责划分 (Separation of Concerns)

这是当前项目最主要的痛点。

*   **现状:**
    *   `server.ts` 文件过于庞大和臃肿。它不仅仅是一个API路由层，还混合了大量的业务逻辑（如读取文件、构造JSON、调用AI任务）、数据转换和直接的文件系统操作。它同时扮演了**控制器(Controller)、服务(Service)和数据访问(Data Access)** 的角色。
    *   `worker.ts` 文件也存在同样的问题。它接收不同类型的作业，然后在一个巨大的函数中通过 `if/else` 或 `switch` 来分发，并且直接在函数内部执行所有业务逻辑。

*   **最佳实践 (改进建议):**
    引入**分层架构 (Layered Architecture)** 是解决这个问题的关键。您可以将代码重构为以下几层：

    1.  **Controller 层 (控制器):**
        *   **职责:** 只负责处理HTTP请求和响应。接收参数，验证输入，然后调用 Service 层来完成实际工作。
        *   **示例:** 创建一个 `src/controllers/compare.controller.ts` 文件，把 `app.post('/api/compare')` 的回调函数逻辑移入其中。`server.ts` 中只保留路由定义和对 controller 的调用。

    2.  **Service 层 (服务):**
        *   **职责:** 封装核心业务逻辑。例如，“执行一次合同比对”或“生成一份PDF报告”都是一个服务。服务可以调用数据访问层或其他服务。
        *   **示例:** 创建一个 `src/services/comparison.service.ts`，它包含执行比对、分析差异、调用AI等所有核心流程。Controller 和 Worker 都可以调用这个服务。

    3.  **Data Access 层 (数据访问):**
        *   **职责:** 抽象所有数据持久化的细节。当前项目是基于文件系统的，`lib/storage.ts` 是一个好的开始，但可以将其正式化为一个“Repository”或“DAO”（数据访问对象）。
        *   **目标:** 让 Service 层在调用 `storage.saveComparison(data)` 时，完全不需要关心数据是存为JSON文件、存入数据库还是上传到云存储。

    通过这样的重构，代码会变得高度模块化、易于测试和复用。

---

### 2. 文件/文件夹命名与组织

*   **现状:**
    *   `src/lib` 是一个通用的“工具箱”，存放了所有共享逻辑。这是一个不错的起点。
    *   `src/lib/ai` 这样按功能划分的子目录也是一个好习惯。
    *   文件名（如 `docx.ts`, `pdf.ts`）清晰明了。

*   **最佳实践 (改进建议):**
    配合分层架构，您可以采用更结构化的目录组织：

    ```
    services/api/src/
    ├── controllers/       # (新增) 控制器层，处理HTTP请求
    │   ├── compare.controller.ts
    │   └── standard.controller.ts
    ├── services/          # (新增) 业务逻辑层
    │   ├── comparison.service.ts
    │   └── analysis.service.ts
    ├── workers/           # (新增) 定义所有后台工作进程的处理器
    │   ├── analysis.worker.ts
    │   └── pdf.worker.ts
    ├── core/              # (替换 lib) 存放更核心的领域逻辑和工具
    │   ├── pdf/
    │   ├── docx/
    │   └── ai/
    ├── repositories/      # (新增) 数据访问层
    │   └── file.repository.ts
    ├── routes/            # (新增) 集中定义所有API路由
    │   └── index.ts
    ├── server.ts          # (简化) 只负责启动服务器和加载路由
    └── worker.ts          # (简化) 只负责启动worker并注册处理器
    ```

    这种结构使得文件的职责一目了然，新人加入项目时能更快地理解代码。

---

### 3. 对“mcp服务”的扩展性

*   **现状:** **非常不方便扩展**。
    *   如果要添加一个新的“mcp服务”，您将不得不再次修改庞大的 `server.ts` 文件来增加新的API路由和业务逻辑。
    *   如果这个新服务也需要后台任务，您还得修改 `worker.ts`，增加新的 `if` 判断，这会让文件越来越难以维护。代码复用率会很低，并且很容易在修改时破坏现有功能。

*   **如何通过重构实现方便扩展:**
    在采纳了上述的分层架构后，添加一个“mcp服务”会变得非常简单和清晰：

    1.  **添加API:** 在 `controllers/` 目录下创建一个 `mcp.controller.ts`。
    2.  **实现业务:** 在 `services/` 目录下创建一个 `mcp.service.ts` 来封装所有核心逻辑。
    3.  **添加后台任务 (如果需要):** 在 `workers/` 目录下创建一个 `mcp.worker.ts`。
    4.  **注册路由:** 在 `routes/` 目录中添加新路由，将其指向 `mcp.controller.ts`。
    5.  **完成!**

    整个过程完全不会影响到现有的“比对”功能，所有新代码都封装在自己的模块里，实现了**高内聚、低耦合**，这是现代软件工程的最佳实践。

### 总结

当前项目有一个非常好的起点和架构方向，但需要通过**引入分层架构**来解决职责划分不清的问题。完成这次重构后，您将拥有一个健壮、可维护、易于扩展的系统，添加新功能（如“mcp服务”）将会变得轻而易举。
